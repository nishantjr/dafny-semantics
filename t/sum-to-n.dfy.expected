    #Not ( {
      _10 +Int _11 *Int ( _11 +Int 1 ) /Int 2
    #Equals
      _1 *Int ( _1 +Int 1 ) /Int 2
    } )
  #And
    {
      Result
    #Equals
      <generatedTop>
        <k>
          .
        </k>
        <methods>
          Main |-> method Main ( .ArgDecls ) returns ( r : int , .ArgDecls ) requires true ensures true { assert Verify ( 0 , .ResultExps ) == 0 ;  assert Verify ( 3 , .ResultExps ) == 6 ;  .Statements }
          Verify |-> method Verify ( n : int , .ArgDecls ) returns ( r : int , .ArgDecls ) requires n >= 0 ensures r == n * ( n + 1 ) / 2 { var i : int ;  r := 0 ;  i := n ;  while ( i > 0 ) invariant r + i * ( i + 1 ) / 2 == n * ( n + 1 ) / 2 && i >= 0 && n >= 0 && r >= 0 { r := r + i ;  i := i - 1 ;  .Statements }  .Statements }
        </methods>
        <stack>
          .List
        </stack>
        <store>
          0 |-> ( _1:Int , var )
          1 |-> ( _10:Int , var )
          2 |-> ( _11:Int , var )
        </store>
        <env>
          i |-> 2
          n |-> 0
          r |-> 1
        </env>
        <nextLoc>
          3
        </nextLoc>
      </generatedTop>
    }
  #And
    {
      true
    #Equals
      _0 >=Int 0
    }
#Or
    {
      Result
    #Equals
      <generatedTop>
        <k>
          .
        </k>
        <methods>
          Main |-> method Main ( .ArgDecls ) returns ( r : int , .ArgDecls ) requires true ensures true { assert Verify ( 0 , .ResultExps ) == 0 ;  assert Verify ( 3 , .ResultExps ) == 6 ;  .Statements }
          Verify |-> method Verify ( n : int , .ArgDecls ) returns ( r : int , .ArgDecls ) requires n >= 0 ensures r == n * ( n + 1 ) / 2 { var i : int ;  r := 0 ;  i := n ;  while ( i > 0 ) invariant r + i * ( i + 1 ) / 2 == n * ( n + 1 ) / 2 && i >= 0 && n >= 0 && r >= 0 { r := r + i ;  i := i - 1 ;  .Statements }  .Statements }
        </methods>
        <stack>
          .List
        </stack>
        <store>
          0 |-> ( _0:Int , var )
          1 |-> ( _00:Int , var )
        </store>
        <env>
          n |-> 0
          r |-> 1
        </env>
        <nextLoc>
          2
        </nextLoc>
      </generatedTop>
    }
  #And
    {
      false
    #Equals
      _0 >=Int 0
    }
#Or
    {
      Result
    #Equals
      <generatedTop>
        <k>
          .
        </k>
        <methods>
          Main |-> method Main ( .ArgDecls ) returns ( r : int , .ArgDecls ) requires true ensures true { assert Verify ( 0 , .ResultExps ) == 0 ;  assert Verify ( 3 , .ResultExps ) == 6 ;  .Statements }
          Verify |-> method Verify ( n : int , .ArgDecls ) returns ( r : int , .ArgDecls ) requires n >= 0 ensures r == n * ( n + 1 ) / 2 { var i : int ;  r := 0 ;  i := n ;  while ( i > 0 ) invariant r + i * ( i + 1 ) / 2 == n * ( n + 1 ) / 2 && i >= 0 && n >= 0 && r >= 0 { r := r + i ;  i := i - 1 ;  .Statements }  .Statements }
        </methods>
        <stack>
          .List
        </stack>
        <store>
          0 |-> ( _1:Int , var )
          1 |-> ( _1 *Int ( _1 +Int 1 ) /Int 2 , var )
          2 |-> ( _11:Int , var )
        </store>
        <env>
          i |-> 2
          n |-> 0
          r |-> 1
        </env>
        <nextLoc>
          3
        </nextLoc>
      </generatedTop>
    }
  #And
    {
      _1 *Int ( _1 +Int 1 ) /Int 2 +Int _11 *Int ( _11 +Int 1 ) /Int 2
    #Equals
      _1 *Int ( _1 +Int 1 ) /Int 2
    }
  #And
    {
      false
    #Equals
      _11 >Int 0
    }
  #And
    {
      true
    #Equals
      _0 >=Int 0
    }
  #And
    {
      true
    #Equals
      _1 *Int ( _1 +Int 1 ) /Int 2 >=Int 0
    }
  #And
    {
      true
    #Equals
      _1 >=Int 0
    }
  #And
    {
      true
    #Equals
      _11 >=Int 0
    }
#Or
    {
      Result
    #Equals
      <generatedTop>
        <k>
          .
        </k>
        <methods>
          Main |-> method Main ( .ArgDecls ) returns ( r : int , .ArgDecls ) requires true ensures true { assert Verify ( 0 , .ResultExps ) == 0 ;  assert Verify ( 3 , .ResultExps ) == 6 ;  .Statements }
          Verify |-> method Verify ( n : int , .ArgDecls ) returns ( r : int , .ArgDecls ) requires n >= 0 ensures r == n * ( n + 1 ) / 2 { var i : int ;  r := 0 ;  i := n ;  while ( i > 0 ) invariant r + i * ( i + 1 ) / 2 == n * ( n + 1 ) / 2 && i >= 0 && n >= 0 && r >= 0 { r := r + i ;  i := i - 1 ;  .Statements }  .Statements }
        </methods>
        <stack>
          .List
        </stack>
        <store>
          0 |-> ( _1:Int , var )
          1 |-> ( _10 +Int _11 , var )
          2 |-> ( _11 -Int 1 , var )
        </store>
        <env>
          i |-> 2
          n |-> 0
          r |-> 1
        </env>
        <nextLoc>
          3
        </nextLoc>
      </generatedTop>
    }
  #And
    {
      _10 +Int _11 *Int ( _11 +Int 1 ) /Int 2
    #Equals
      _1 *Int ( _1 +Int 1 ) /Int 2
    }
  #And
    {
      _10 +Int _11 +Int ( _11 -Int 1 ) *Int ( _11 -Int 1 +Int 1 ) /Int 2
    #Equals
      _1 *Int ( _1 +Int 1 ) /Int 2
    }
  #And
    {
      true
    #Equals
      _0 >=Int 0
    }
  #And
    {
      true
    #Equals
      _1 >=Int 0
    }
  #And
    {
      true
    #Equals
      _10 +Int _11 >=Int 0
    }
  #And
    {
      true
    #Equals
      _10 >=Int 0
    }
  #And
    {
      true
    #Equals
      _11 -Int 1 >=Int 0
    }
  #And
    {
      true
    #Equals
      _11 >=Int 0
    }
  #And
    {
      true
    #Equals
      _11 >Int 0
    }
#Or
    {
      Result
    #Equals
      <generatedTop>
        <k>
          .
        </k>
        <methods>
          Main |-> method Main ( .ArgDecls ) returns ( r : int , .ArgDecls ) requires true ensures true { assert Verify ( 0 , .ResultExps ) == 0 ;  assert Verify ( 3 , .ResultExps ) == 6 ;  .Statements }
          Verify |-> method Verify ( n : int , .ArgDecls ) returns ( r : int , .ArgDecls ) requires n >= 0 ensures r == n * ( n + 1 ) / 2 { var i : int ;  r := 0 ;  i := n ;  while ( i > 0 ) invariant r + i * ( i + 1 ) / 2 == n * ( n + 1 ) / 2 && i >= 0 && n >= 0 && r >= 0 { r := r + i ;  i := i - 1 ;  .Statements }  .Statements }
        </methods>
        <stack>
          .List
        </stack>
        <store>
          0 |-> ( _1:Int , var )
          1 |-> ( _10:Int , var )
          2 |-> ( _11:Int , var )
        </store>
        <env>
          i |-> 2
          n |-> 0
          r |-> 1
        </env>
        <nextLoc>
          3
        </nextLoc>
      </generatedTop>
    }
  #And
    {
      _10 +Int _11 *Int ( _11 +Int 1 ) /Int 2
    #Equals
      _1 *Int ( _1 +Int 1 ) /Int 2
    }
  #And
    {
      false
    #Equals
      _1 >=Int 0
    }
  #And
    {
      true
    #Equals
      _0 >=Int 0
    }
  #And
    {
      true
    #Equals
      _11 >=Int 0
    }
#Or
    {
      Result
    #Equals
      <generatedTop>
        <k>
          .
        </k>
        <methods>
          Main |-> method Main ( .ArgDecls ) returns ( r : int , .ArgDecls ) requires true ensures true { assert Verify ( 0 , .ResultExps ) == 0 ;  assert Verify ( 3 , .ResultExps ) == 6 ;  .Statements }
          Verify |-> method Verify ( n : int , .ArgDecls ) returns ( r : int , .ArgDecls ) requires n >= 0 ensures r == n * ( n + 1 ) / 2 { var i : int ;  r := 0 ;  i := n ;  while ( i > 0 ) invariant r + i * ( i + 1 ) / 2 == n * ( n + 1 ) / 2 && i >= 0 && n >= 0 && r >= 0 { r := r + i ;  i := i - 1 ;  .Statements }  .Statements }
        </methods>
        <stack>
          .List
        </stack>
        <store>
          0 |-> ( _1:Int , var )
          1 |-> ( _10:Int , var )
          2 |-> ( _11:Int , var )
        </store>
        <env>
          i |-> 2
          n |-> 0
          r |-> 1
        </env>
        <nextLoc>
          3
        </nextLoc>
      </generatedTop>
    }
  #And
    {
      _10 +Int _11 *Int ( _11 +Int 1 ) /Int 2
    #Equals
      _1 *Int ( _1 +Int 1 ) /Int 2
    }
  #And
    {
      false
    #Equals
      _10 >=Int 0
    }
  #And
    {
      true
    #Equals
      _0 >=Int 0
    }
  #And
    {
      true
    #Equals
      _1 >=Int 0
    }
  #And
    {
      true
    #Equals
      _11 >=Int 0
    }
#Or
    {
      Result
    #Equals
      <generatedTop>
        <k>
          .
        </k>
        <methods>
          Main |-> method Main ( .ArgDecls ) returns ( r : int , .ArgDecls ) requires true ensures true { assert Verify ( 0 , .ResultExps ) == 0 ;  assert Verify ( 3 , .ResultExps ) == 6 ;  .Statements }
          Verify |-> method Verify ( n : int , .ArgDecls ) returns ( r : int , .ArgDecls ) requires n >= 0 ensures r == n * ( n + 1 ) / 2 { var i : int ;  r := 0 ;  i := n ;  while ( i > 0 ) invariant r + i * ( i + 1 ) / 2 == n * ( n + 1 ) / 2 && i >= 0 && n >= 0 && r >= 0 { r := r + i ;  i := i - 1 ;  .Statements }  .Statements }
        </methods>
        <stack>
          .List
        </stack>
        <store>
          0 |-> ( _1:Int , var )
          1 |-> ( _10:Int , var )
          2 |-> ( _11:Int , var )
        </store>
        <env>
          i |-> 2
          n |-> 0
          r |-> 1
        </env>
        <nextLoc>
          3
        </nextLoc>
      </generatedTop>
    }
  #And
    {
      _10 +Int _11 *Int ( _11 +Int 1 ) /Int 2
    #Equals
      _1 *Int ( _1 +Int 1 ) /Int 2
    }
  #And
    {
      false
    #Equals
      _11 >=Int 0
    }
  #And
    {
      true
    #Equals
      _0 >=Int 0
    }
